task:
1. 課題の全消化(試験，アメフト)
2. 勝率の推移のグラフ描画
3. 2駒関係で勝率の上限突破を確認
4. mc法と有効性の確認
5. ロジスティック回帰の実装
6. 重みの書き込みと読み込みの実装


今後の方針:
v4:
工房のgeister.pyに移行．ランダムプレイヤでも十秒で一万局やれる．速い(?)
tdagentの動作確認．
次にやるのは三駒td，三駒mcの実装と効果の確認．
その後，三駒mc+例のアレをやる．

大会前に通信テストを行いたい．

v3:
get_after_statesにバグを発見．
  test_tdで時間がかかりすぎるのはバグっぽい
  とりあえずテスト増やそう...
やはり，先生のやつも使ってみてその後に検討かなぁ．
ただC言語だと...MCはキュー使うし...afterstatesは可変長だし...
  ->MCはキュー使え，afterstatesは固定長配列の一部を使え
      (afterstateの最大数=最大有効候補手，は決まってる．8*4)
とは言え，C言語はキツイから，線形近似くらいは使っとこう．


v2:
ガイスター初回の内容にもよるが，boardの軽量化の後，線形強化学習，三駒が望ましい．
ただこれくらいの内容ならC言語でもなんとかなる気はする．
(内積は配列でやって良さそうな大きさだし，三ゴマ関係はどうせ実装必須)

まず，遅すぎる．boardの仕様が原因だと考えられる．
正直，ランダムな相手どころかpassAgentに対してさえ学習できそうにない．
現状，一秒あたり1000ターンしかできない．
最後の一手が偶然起こるのを待つのに0.2s程かかる(学習は無謀)
まぁ，先生のやつ使うのが前提かなぁ...
とは言え，線形近似くらいは使用経験がないときつそうなので，
初期状態をなんか作っておいてそこから学習させましょうか．

->時間がかかりすぎるのはバグっぽい

v1:
まずランダムな固定相手に対して線形関数近似で強化学習させる．
仕様上，常に先攻であるとする
有用性を確認できるはず

boardの仕様変更(orプラットフォームの移行orAgent側で対応)により，
後攻でも対応できるようにする．
具体的には後攻のプレイヤーにデータを渡すときともらうときに盤面の反転を行う
